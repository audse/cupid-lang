- file: expression+
-~expression: package | comment | statement | term

- package: 'package' name_space? items
- name_space: WORD ':' ':' name_space?
-~items: '[' (WORD ',')* ']' | WORD

-~statement:
	type_definition
	| trait_definition
	| implement_type
	| implement_trait
	| typed_declaration
	| break
	| return
	| continue
	| op_assignment
	| assignment
	| property_assignment
	| property_op_assignment
	| log

-~term:
	loop
	| block
	| function
	| no_op
	| property_access
	| operation

-~loop:
	for_loop
	| while_loop
	| infinite_loop

- for_loop: 'for' for_loop_parameters ~'in' term block
- for_loop_parameters: (identifier ~',')*
- while_loop: 'while' term block
- infinite_loop: 'loop' block

- block: 
	if_block
	| box_block
	| brace_block
	| arrow_block
	
- if_block: ~'if' term block else_if_block* else_block?
- else_if_block: ~'else' ~'if' term block
- else_block: ~'else' block
- box_block: ~'box' brace_block
-~brace_block: ~'{' expression* closing_brace
-~arrow_block: ~arrow expression

- assignment: identifier equal term
- property_assignment: property_access equal term

- property_op_assignment: property_access operator equal term
- property_access: atom '.' term

- op_assignment: identifier operator equal term
-~operator: '+' | '-' | '*' | '/' | '^' | '%'

-~type_definition:
	builtin_type_definition
	| struct_type_definition
	| sum_type_definition
	| alias_type_definition

- builtin_type_definition: 'type' WORD !'='

- struct_type_definition: type_symbol ~equal '[' (struct_member ~',')* ~']'
- struct_member: type_hint identifier

- sum_type_definition: type_symbol ~equal '[' (sum_member ~',')* ~']'
- sum_member: type_hint

- alias_type_definition: type_symbol ~equal type_hint

-~type_symbol: 'type' generics? identifier
- generics: '[' (generic_argument ',')* closing_bracket
- generic_argument: identifier !':' | identifier ':' type_hint

- typed_declaration: type_hint 'mut'? identifier (~equal term)?

-~type_hint:
	array_type_hint
	| function_type_hint
	| map_type_hint
	| struct_type_hint
	| primitive_type_hint

- array_type_hint: array_kw '[' type_hint closing_bracket
- map_type_hint: map_kw '[' type_hint ',' type_hint closing_bracket
- function_type_hint: fun_kw '[' type_hint closing_bracket
- primitive_type_hint: identifier
- array_kw: 'array'
- map_kw: 'map'
- fun_kw: 'fun'

- struct_type_hint: identifier '[' (struct_member_type_hint ',')* ']'
- struct_member_type_hint: identifier ':' type_hint

- implement_type: 'use' generics? type_hint '{' typed_declaration* closing_brace

- implement_trait: 'use' generics? identifier 'with' type_hint implement_trait_body?
-~implement_trait_body: '{' typed_declaration* closing_brace

- trait_definition: 'trait' generics identifier ~equal ~'[' (typed_declaration ',')* closing_bracket

-~equal: '=' !'>'

-~atom:
	empty
	| function_call
	| range
	| map
	| bracket_array
	| group
	| unary_op
	| boolean
	| none
	| string
	| char
	| decimal
	| number
	| self
	| identifier

- empty: ~'_'
- group: ~'(' term? closing_paren
- function: parameters  function_body
-~function_body: arrow ~empty | arrow group | block
- parameters: (parameter ~',')*
-~parameter: ~'_' | 'mut'? self | annotated_parameter
- annotated_parameter: type_hint identifier

- log: log_keyword ~'(' arguments closing_paren
- function_call: identifier ~'(' arguments closing_paren
- arguments: (term ~',')*

-~log_keyword: 'log' | 'logs' | 'log_line' | 'logs_line'

- bracket_array: '[' !'.' array? !'.' closing_bracket
-~array:  (term ~',')* term?

- map: '[' (map_entry !']' ',')* ']'
- map_entry: atom ':' term

- range: 
	range_inclusive_inclusive
	| range_inclusive_exclusive
	| range_exclusive_inclusive
	| range_exclusive_exclusive

- range_inclusive_inclusive: '[' range_term ~'.' ~'.' range_term ']'
- range_inclusive_exclusive: '[' range_term ~'.' ~'.' ']' range_term
- range_exclusive_inclusive: range_term '[' ~'.' ~'.' range_term ']'
- range_exclusive_exclusive: range_term '[' ~'.' ~'.' ']' range_term
-~range_term: function_call | group | unary_op | number | identifier

# operations can be kinda slow, going through all that, so this is a shortcut
-~no_op: !'-' atom !'.' !operator !keyword_operator

-~operation: binary_op

-~binary_op: type_cast
 
- type_cast: compare_op type_cast_suffix?
-~type_cast_suffix: 'as' type_hint

- compare_op: add compare_suffix?
-~compare_suffix: keyword_operator compare_op

- add: multiply add_suffix?
-~add_suffix: '+' add | '-' add

- multiply: exponent multiply_suffix?
-~multiply_suffix: '*' multiply | '/' multiply | '%' multiply

- exponent: atom exponent_suffix?
-~exponent_suffix: '^' exponent

- unary_op: '-' atom

- break: 'break' term?
- return: 'return' term?
- continue: 'continue'

- boolean: 'true' | 'false'
- none: 'none'
- identifier: !keyword WORD
- char: '\\' LETTER 
- string: STRING
- decimal: NUMBER ~'.' NUMBER
- number: NUMBER

# Error handling
-~require_term: term | <e 'missing expression'>
-~closing_paren: ~')' | <e 'missing closing parenthesis'>
-~closing_brace: ~'}' | <e 'missing closing brace'>
-~closing_bracket: ~']' | <e 'missing closing bracket'>

-~keyword:
	keyword_variable
	| keyword_operator
	| reserved_word
	| boolean
	| none

- self: 'self'

-~reserved_word:
	'for'
	| 'while'
	| 'else'
	| 'if'
	| 'mut'
	| 'loop'
	| 'box'
	| 'break'
	| 'return'
	| 'continue'
	| 'type'
	| 'log'
	| 'logs'
	| 'log_line'
	| 'logs_line'
	| 'use'
	| 'trait'
	| 'self'
	| 'array'
	| 'fun'
	| 'map'

-~keyword_variable:
	'let'
	| 'const'

-~keyword_operator:
	'in'
	| 'is'
	| 'and'
	| 'not'
	| 'or'
	| 'as'
	| 'istype'
	| '>'
	| '>' '='
	| '<'
	| '<' '='

- arrow: ~'=' ~'>'
	
-~comment_delimiter: '*' '*' '*'
-~comment_content: ANY !comment_delimiter
- comment: ~comment_delimiter comment_content* ANY ~comment_delimiter